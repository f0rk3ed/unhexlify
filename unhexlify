#!/usr/bin/env python3

import argparse
import os
import sys
import re

# Nuclear Approach: Combine the best of all worlds
# Pre-compiled patterns for maximum efficiency
UNICODE_PATTERN = re.compile(r'\\u\{([0-9A-Fa-f]{1,6})\}')
HEX_PATTERN = re.compile(r'\\x([0-9A-Fa-f]{2})')

# Pre-computed lookup table for common hex escapes (0-255)
HEX_CACHE = {}
for i in range(256):
    HEX_CACHE[f'{i:02x}'] = chr(i)
    HEX_CACHE[f'{i:02X}'] = chr(i)

def nuclear_hex_replacer(match):
    """Ultra-fast hex replacer using pre-computed cache"""
    hex_val = match.group(1)
    return HEX_CACHE.get(hex_val.lower(), chr(int(hex_val, 16)))

def nuclear_unicode_replacer(match):
    """Ultra-fast unicode replacer with validation"""
    hex_val = match.group(1)
    codepoint = int(hex_val, 16)
    if codepoint > 0x10FFFF:
        raise ValueError(f"Invalid unicode: {hex_val}")
    return chr(codepoint)

def nuclear_decode(data: str) -> str:
    """Nuclear option: Fastest possible implementation"""
    # Lightning-fast path: no escapes
    if '\\' not in data:
        return data
    
    # Determine which escapes are present to optimize processing
    has_unicode = '\\u{' in data
    has_hex = '\\x' in data
    
    if not has_unicode and not has_hex:
        return data  # No relevant escapes
    
    # Process based on what's present
    if has_hex and not has_unicode:
        # Only hex escapes - use optimized path
        return HEX_PATTERN.sub(nuclear_hex_replacer, data)
    elif has_unicode and not has_hex:
        # Only unicode escapes
        return UNICODE_PATTERN.sub(nuclear_unicode_replacer, data)
    else:
        # Both types - process in optimal order (hex first, usually faster)
        data = HEX_PATTERN.sub(nuclear_hex_replacer, data)
        return UNICODE_PATTERN.sub(nuclear_unicode_replacer, data)

def read_input(arg, enc):
    if arg is None or arg == "-":
        return sys.stdin.buffer.read().decode(enc)
    if os.path.exists(arg):
        with open(arg, "rt", encoding=enc) as fp:
            return fp.read()
    return arg

def main():
    p = argparse.ArgumentParser(add_help=True)
    p.add_argument("input", nargs="?")
    p.add_argument("--errors", default="strict", choices=("strict","ignore","replace"))
    p.add_argument("--encoding", default="utf-8")
    a = p.parse_args()
    try:
        sys.stdout.write(nuclear_decode(read_input(a.input, a.encoding)))
    except Exception as e:
        sys.stderr.write(f"{e}\n")
        return 1
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
